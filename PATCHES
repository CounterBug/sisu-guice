Index: core/test/com/googlecode/guice/BytecodeGenTest.java
===================================================================
--- core/test/com/googlecode/guice/BytecodeGenTest.java	(revision 1319)
+++ core/test/com/googlecode/guice/BytecodeGenTest.java	(working copy)
@@ -197,6 +197,7 @@
     }
   }
   
+/*******************************************************************************
   public void testProxyClassUnloading() {
     Object testObject = Guice.createInjector(interceptorModule, testModule)
         .getInstance(proxyTestClass);
@@ -211,10 +212,10 @@
     // null the proxy
     testObject = null;
 
-    /*
+    |*
      * this should be enough to queue the weak reference
      * unless something is holding onto it accidentally.
-     */
+     *|
     String[] buf;
     System.gc();
     buf = new String[8 * 1024 * 1024];
@@ -234,6 +235,7 @@
     // If it fails, run the test again to make sure it's failing reliably.
     assertNull(clazzRef.get());
   }
+*******************************************************************************/
 
   public void testProxyingPackagePrivateMethods() {
     Injector injector = Guice.createInjector(interceptorModule);
Index: core/test/com/google/inject/TypeConversionTest.java
===================================================================
--- core/test/com/google/inject/TypeConversionTest.java	(revision 1319)
+++ core/test/com/google/inject/TypeConversionTest.java	(working copy)
@@ -19,7 +19,9 @@
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.matcher.Matchers;
+import com.google.inject.spi.ConvertedConstantBinding;
 import com.google.inject.spi.TypeConverter;
+import com.google.inject.spi.TypeConverterBinding;
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.util.Date;
@@ -209,6 +211,14 @@
     });
 
     assertSame(result, injector.getInstance(DateHolder.class).date);
+
+    Binding<Date> binding = injector.getBinding(Key.get(Date.class, NumericValue.class));
+    assertTrue(binding instanceof ConvertedConstantBinding<?>);
+
+    TypeConverterBinding converterBinding = ((ConvertedConstantBinding<?>)binding).getTypeConverterBinding();
+    assertEquals("CustomConverter", converterBinding.getTypeConverter().toString());
+
+    assertTrue(injector.getTypeConverterBindings().contains(converterBinding));
   }
 
   public void testInvalidCustomValue() throws CreationException {
Index: core/test/com/google/inject/AllTests.java
===================================================================
--- core/test/com/google/inject/AllTests.java	(revision 1319)
+++ core/test/com/google/inject/AllTests.java	(working copy)
@@ -44,12 +44,13 @@
 import java.util.Enumeration;
 import java.util.Set;
 import junit.framework.Test;
+import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
 /**
  * @author crazybob@google.com (Bob Lee)
  */
-public class AllTests {
+public class AllTests extends TestCase {
 
   private static final Set<String> SUPPRESSED_TEST_NAMES = ImmutableSet.of(
       "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
@@ -145,7 +146,7 @@
 
     // googlecode.guice
     suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
-    suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
+////suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
     suite.addTestSuite(Jsr330Test.class);
 
     return removeSuppressedTests(suite, SUPPRESSED_TEST_NAMES);
Index: core/src/com/google/inject/name/NamedImpl.java
===================================================================
--- core/src/com/google/inject/name/NamedImpl.java	(revision 1319)
+++ core/src/com/google/inject/name/NamedImpl.java	(working copy)
@@ -38,12 +38,13 @@
   }
 
   public boolean equals(Object o) {
-    if (!(o instanceof Named)) {
-      return false;
+    if (o == this) {
+      return true;
     }
-
-    Named other = (Named) o;
-    return value.equals(other.value());
+    if (o instanceof Named) {
+      return value.equals(((Named) o).value());
+    }
+    return false;
   }
 
   public String toString() {
Index: core/src/com/google/inject/spi/ConvertedConstantBinding.java
===================================================================
--- core/src/com/google/inject/spi/ConvertedConstantBinding.java	(revision 1319)
+++ core/src/com/google/inject/spi/ConvertedConstantBinding.java	(working copy)
@@ -35,6 +35,11 @@
   T getValue();
 
   /**
+   * Returns the type converter binding used to convert the constant.
+   */
+  TypeConverterBinding getTypeConverterBinding();
+
+  /**
    * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
Index: core/src/com/google/inject/spi/TypeConverterBinding.java
===================================================================
--- core/src/com/google/inject/spi/TypeConverterBinding.java	(revision 1319)
+++ core/src/com/google/inject/spi/TypeConverterBinding.java	(working copy)
@@ -36,7 +36,7 @@
   private final Matcher<? super TypeLiteral<?>> typeMatcher;
   private final TypeConverter typeConverter;
 
-  TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
+  public TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter typeConverter) {
     this.source = checkNotNull(source, "source");
     this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
@@ -62,4 +62,9 @@
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
   }
+
+  @Override public String toString() {
+    return typeConverter + " which matches " + typeMatcher
+        + " (bound at " + source + ")";
+  }
 }
Index: core/src/com/google/inject/internal/BindingProcessor.java
===================================================================
--- core/src/com/google/inject/internal/BindingProcessor.java	(revision 1319)
+++ core/src/com/google/inject/internal/BindingProcessor.java	(working copy)
@@ -51,6 +51,12 @@
  */
 final class BindingProcessor extends AbstractProcessor {
 
+//------------------------------------------------------------------------------
+  private static final boolean DISABLE_MISPLACED_ANNOTATION_CHECK
+      = Boolean.parseBoolean(System.getProperty(
+          "guice.disable.misplaced.annotation.check", "false"));
+//------------------------------------------------------------------------------
+
   private final List<CreationListener> creationListeners = Lists.newArrayList();
   private final Initializer initializer;
   private final List<Runnable> uninitializedBindings = Lists.newArrayList();
@@ -221,8 +227,14 @@
   }
 
   private <T> void validateKey(Object source, Key<T> key) {
+//------------------------------------------------------------------------------
+if (!DISABLE_MISPLACED_ANNOTATION_CHECK) {
+//------------------------------------------------------------------------------
     Annotations.checkForMisplacedScopeAnnotations(
         key.getTypeLiteral().getRawType(), source, errors);
+//------------------------------------------------------------------------------
+}
+//------------------------------------------------------------------------------
   }
 
   <T> UntargettedBindingImpl<T> invalidBinding(InjectorImpl injector, Key<T> key, Object source) {
Index: core/src/com/google/inject/internal/Errors.java
===================================================================
--- core/src/com/google/inject/internal/Errors.java	(revision 1319)
+++ core/src/com/google/inject/internal/Errors.java	(working copy)
@@ -33,6 +33,7 @@
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.io.PrintWriter;
 import java.io.Serializable;
@@ -51,7 +52,7 @@
 
 /**
  * A collection of error messages. If this type is passed as a method parameter, the method is
- * considered to have executed succesfully only if new errors were not added to this collection.
+ * considered to have executed successfully only if new errors were not added to this collection.
  *
  * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
  * to create a new Errors instance that contains additional context. All messages added to the
@@ -135,30 +136,30 @@
   }
 
   public Errors converterReturnedNull(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
         + " using %s.",
-        stringValue, convert(source), type, matchingConverter);
+        stringValue, convert(source), type, typeConverterBinding);
   }
 
   public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter matchingConverter, Object converted) {
+      TypeConverterBinding typeConverterBinding, Object converted) {
     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Converter returned %s.",
-        stringValue, convert(source), type, matchingConverter, converted);
+        stringValue, convert(source), type, typeConverterBinding, converted);
   }
 
   public Errors conversionError(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding, RuntimeException cause) {
     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Reason: %s",
-        stringValue, convert(source), type, matchingConverter, cause);
+        stringValue, convert(source), type, typeConverterBinding, cause);
   }
 
   public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter a, MatcherAndConverter b) {
+      TypeConverterBinding a, TypeConverterBinding b) {
     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n"
         + " %s and%n"
         + " %s.%n"
@@ -608,7 +609,7 @@
     }
 
     boolean appliesTo(Object o) {
-      return type.isAssignableFrom(o.getClass());
+      return o != null && type.isAssignableFrom(o.getClass());
     }
 
     String convert(Object o) {
Index: core/src/com/google/inject/internal/InjectorImpl.java
===================================================================
--- core/src/com/google/inject/internal/InjectorImpl.java	(revision 1319)
+++ core/src/com/google/inject/internal/InjectorImpl.java	(working copy)
@@ -45,6 +45,7 @@
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.ProviderBinding;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
@@ -376,9 +377,9 @@
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
-    MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
+    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
 
-    if (matchingConverter == null) {
+    if (typeConverterBinding == null) {
       // No converter can handle the given type.
       return null;
     }
@@ -386,23 +387,24 @@
     // Try to convert the string. A failed conversion results in an error.
     try {
       @SuppressWarnings("unchecked") // This cast is safe because we double check below.
-      T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type);
+      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
 
       if (converted == null) {
-        throw errors.converterReturnedNull(stringValue, source, type, matchingConverter)
+        throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding)
             .toException();
       }
 
       if (!type.getRawType().isInstance(converted)) {
-        throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted)
+        throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted)
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding,
+          typeConverterBinding);
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
-      throw errors.conversionError(stringValue, source, type, matchingConverter, e)
+      throw errors.conversionError(stringValue, source, type, typeConverterBinding, e)
           .toException();
     }
   }
@@ -412,14 +414,17 @@
     final T value;
     final Provider<T> provider;
     final Binding<String> originalBinding;
+    final TypeConverterBinding typeConverterBinding;
 
     ConvertedConstantBindingImpl(
-        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding) {
+        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding,
+        TypeConverterBinding typeConverterBinding) {
       super(injector, key, originalBinding.getSource(),
           new ConstantFactory<T>(Initializables.of(value)), Scoping.UNSCOPED);
       this.value = value;
       provider = Providers.of(value);
       this.originalBinding = originalBinding;
+      this.typeConverterBinding = typeConverterBinding;
     }
 
     @Override public Provider<T> getProvider() {
@@ -434,6 +439,10 @@
       return value;
     }
 
+    public TypeConverterBinding getTypeConverterBinding() {
+      return typeConverterBinding;
+    }
+
     public Key<String> getSourceKey() {
       return originalBinding.getKey();
     }
@@ -828,9 +837,13 @@
   }
 
   public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
-    return state.getScopes();
+    return Collections.unmodifiableMap(state.getScopes());
   }
 
+  public List<TypeConverterBinding> getTypeConverterBindings() {
+    return Collections.unmodifiableList(state.getConvertersThisLevel());
+  }
+
   private static class BindingsMultimap {
     final Map<TypeLiteral<?>, List<Binding<?>>> multimap = Maps.newHashMap();
 
Index: core/src/com/google/inject/internal/InjectorShell.java
===================================================================
--- core/src/com/google/inject/internal/InjectorShell.java	(revision 1319)
+++ core/src/com/google/inject/internal/InjectorShell.java	(working copy)
@@ -229,6 +229,15 @@
         new ProviderInstanceBindingImpl<Logger>(injector, key,
             SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED,
             loggerFactory, ImmutableSet.<InjectionPoint>of()));
+
+    try {
+      Key<org.slf4j.Logger> slf4jKey = Key.get(org.slf4j.Logger.class);
+      SLF4JLoggerFactory slf4jLoggerFactory = new SLF4JLoggerFactory();
+      injector.state.putBinding(slf4jKey,
+          new ProviderInstanceBindingImpl<org.slf4j.Logger>(injector, slf4jKey,
+              SourceProvider.UNKNOWN_SOURCE, slf4jLoggerFactory, Scoping.UNSCOPED,
+              slf4jLoggerFactory, ImmutableSet.<InjectionPoint>of()));
+    } catch (Throwable e) {}
   }
 
   private static class LoggerFactory implements InternalFactory<Logger>, Provider<Logger> {
@@ -248,6 +257,23 @@
     }
   }
 
+  private static class SLF4JLoggerFactory implements InternalFactory<org.slf4j.Logger>, Provider<org.slf4j.Logger> {
+    public org.slf4j.Logger get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked) {
+      InjectionPoint injectionPoint = dependency.getInjectionPoint();
+      return injectionPoint == null
+          ? org.slf4j.LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME)
+          : org.slf4j.LoggerFactory.getLogger(injectionPoint.getMember().getDeclaringClass());
+    }
+
+    public org.slf4j.Logger get() {
+      return org.slf4j.LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
+    }
+
+    public String toString() {
+      return "Provider<org.slf4j.Logger>";
+    }
+  }
+
   private static class RootModule implements Module {
     final Stage stage;
 
Index: core/src/com/google/inject/internal/InheritingState.java
===================================================================
--- core/src/com/google/inject/internal/InheritingState.java	(revision 1319)
+++ core/src/com/google/inject/internal/InheritingState.java	(working copy)
@@ -24,6 +24,7 @@
 import com.google.inject.internal.util.Lists;
 import com.google.inject.internal.util.Maps;
 import static com.google.inject.internal.util.Preconditions.checkNotNull;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
@@ -43,7 +44,7 @@
   private final Map<Key<?>, Binding<?>> explicitBindings
       = Collections.unmodifiableMap(explicitBindingsMutable);
   private final Map<Class<? extends Annotation>, Scope> scopes = Maps.newHashMap();
-  private final List<MatcherAndConverter> converters = Lists.newArrayList();
+  private final List<TypeConverterBinding> converters = Lists.newArrayList();
   /*if[AOP]*/
   private final List<MethodAspect> methodAspects = Lists.newArrayList();
   /*end[AOP]*/
@@ -83,19 +84,19 @@
     scopes.put(annotationType, scope);
   }
 
-  public Iterable<MatcherAndConverter> getConvertersThisLevel() {
+  public List<TypeConverterBinding> getConvertersThisLevel() {
     return converters;
   }
 
-  public void addConverter(MatcherAndConverter matcherAndConverter) {
-    converters.add(matcherAndConverter);
+  public void addConverter(TypeConverterBinding typeConverterBinding) {
+    converters.add(typeConverterBinding);
   }
 
-  public MatcherAndConverter getConverter(
+  public TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source) {
-    MatcherAndConverter matchingConverter = null;
+    TypeConverterBinding matchingConverter = null;
     for (State s = this; s != State.NONE; s = s.parent()) {
-      for (MatcherAndConverter converter : s.getConvertersThisLevel()) {
+      for (TypeConverterBinding converter : s.getConvertersThisLevel()) {
         if (converter.getTypeMatcher().matches(type)) {
           if (matchingConverter != null) {
             errors.ambiguousTypeConversion(stringValue, source, type, matchingConverter, converter);
Index: core/src/com/google/inject/internal/TypeConverterBindingProcessor.java
===================================================================
--- core/src/com/google/inject/internal/TypeConverterBindingProcessor.java	(revision 1319)
+++ core/src/com/google/inject/internal/TypeConverterBindingProcessor.java	(working copy)
@@ -161,12 +161,12 @@
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBinding(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }
Index: core/src/com/google/inject/internal/State.java
===================================================================
--- core/src/com/google/inject/internal/State.java	(revision 1319)
+++ core/src/com/google/inject/internal/State.java	(working copy)
@@ -23,6 +23,7 @@
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableMap;
 import com.google.inject.internal.util.ImmutableSet;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.List;
@@ -61,17 +62,17 @@
       throw new UnsupportedOperationException();
     }
 
-    public void addConverter(MatcherAndConverter matcherAndConverter) {
+    public void addConverter(TypeConverterBinding typeConverterBinding) {
       throw new UnsupportedOperationException();
     }
 
-    public MatcherAndConverter getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
+    public TypeConverterBinding getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
         Object source) {
       throw new UnsupportedOperationException();
     }
 
-    public Iterable<MatcherAndConverter> getConvertersThisLevel() {
-      return ImmutableSet.of();
+    public List<TypeConverterBinding> getConvertersThisLevel() {
+      return ImmutableList.of();
     }
 
     /*if[AOP]*/
@@ -123,14 +124,14 @@
 
   void putAnnotation(Class<? extends Annotation> annotationType, Scope scope);
 
-  void addConverter(MatcherAndConverter matcherAndConverter);
+  void addConverter(TypeConverterBinding typeConverterBinding);
 
   /** Returns the matching converter for {@code type}, or null if none match. */
-  MatcherAndConverter getConverter(
+  TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source);
 
   /** Returns all converters at this level only. */
-  Iterable<MatcherAndConverter> getConvertersThisLevel();
+  List<TypeConverterBinding> getConvertersThisLevel();
 
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
Index: core/src/com/google/inject/internal/InternalInjectorCreator.java
===================================================================
--- core/src/com/google/inject/internal/InternalInjectorCreator.java	(revision 1319)
+++ core/src/com/google/inject/internal/InternalInjectorCreator.java	(working copy)
@@ -29,6 +29,7 @@
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.internal.util.Stopwatch;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.TypeConverterBinding;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -287,6 +288,9 @@
     public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
       return delegateInjector.getScopeBindings();
     }
+    public List<TypeConverterBinding> getTypeConverterBindings() {
+      return delegateInjector.getTypeConverterBindings();
+    }
     public <T> Provider<T> getProvider(Key<T> key) {
       throw new UnsupportedOperationException(
         "Injector.getProvider(Key<T>) is not supported in Stage.TOOL");
Index: core/src/com/google/inject/Injector.java
===================================================================
--- core/src/com/google/inject/Injector.java	(revision 1319)
+++ core/src/com/google/inject/Injector.java	(working copy)
@@ -20,6 +20,8 @@
 import java.util.List;
 import java.util.Map;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
@@ -247,4 +249,12 @@
    * @since 3.0
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Returns a list containing all type converter bindings in the injector. The returned list
+   * is immutable.
+   *
+   * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
+   */
+  List<TypeConverterBinding> getTypeConverterBindings();
 }
Index: extensions/mini/src/com/google/inject/mini/MiniGuice.java
===================================================================
--- extensions/mini/src/com/google/inject/mini/MiniGuice.java	(revision 1319)
+++ extensions/mini/src/com/google/inject/mini/MiniGuice.java	(working copy)
@@ -23,11 +23,11 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
@@ -45,7 +45,7 @@
   private MiniGuice() {}
 
   private final Map<Key, Provider<?>> bindings = new HashMap<Key, Provider<?>>();
-  private final Queue<RequiredKey> requiredKeys = new ArrayDeque<RequiredKey>();
+  private final Queue<RequiredKey> requiredKeys = new LinkedList<RequiredKey>();
   private final Set<Key> singletons = new HashSet<Key>();
 
   /**
