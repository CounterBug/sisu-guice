diff --git a/core/src/main/java/com/google/inject/Injector.java b/core/src/main/java/com/google/inject/Injector.java
index 64b584e..eff67ad 100644
--- a/core/src/main/java/com/google/inject/Injector.java
+++ b/core/src/main/java/com/google/inject/Injector.java
@@ -20,6 +20,8 @@ import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
@@ -247,4 +249,12 @@ public interface Injector {
    * @since 3.0
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Returns a list containing all type converter bindings in the injector. The returned list
+   * is immutable.
+   *
+   * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
+   */
+  List<TypeConverterBinding> getTypeConverterBindings();
 }
diff --git a/core/src/main/java/com/google/inject/internal/BindingProcessor.java b/core/src/main/java/com/google/inject/internal/BindingProcessor.java
index 38af5c0..b166c1a 100644
--- a/core/src/main/java/com/google/inject/internal/BindingProcessor.java
+++ b/core/src/main/java/com/google/inject/internal/BindingProcessor.java
@@ -51,6 +51,12 @@ import java.util.Set;
  */
 final class BindingProcessor extends AbstractProcessor {
 
+//------------------------------------------------------------------------------
+  private static final boolean DISABLE_MISPLACED_ANNOTATION_CHECK
+      = Boolean.parseBoolean(System.getProperty(
+          "guice.disable.misplaced.annotation.check", "false"));
+//------------------------------------------------------------------------------
+
   private final List<CreationListener> creationListeners = Lists.newArrayList();
   private final Initializer initializer;
   private final List<Runnable> uninitializedBindings = Lists.newArrayList();
@@ -221,8 +227,14 @@ final class BindingProcessor extends AbstractProcessor {
   }
 
   private <T> void validateKey(Object source, Key<T> key) {
+//------------------------------------------------------------------------------
+if (!DISABLE_MISPLACED_ANNOTATION_CHECK) {
+//------------------------------------------------------------------------------
     Annotations.checkForMisplacedScopeAnnotations(
         key.getTypeLiteral().getRawType(), source, errors);
+//------------------------------------------------------------------------------
+}
+//------------------------------------------------------------------------------
   }
 
   <T> UntargettedBindingImpl<T> invalidBinding(InjectorImpl injector, Key<T> key, Object source) {
diff --git a/core/src/main/java/com/google/inject/internal/Errors.java b/core/src/main/java/com/google/inject/internal/Errors.java
index 84fd96e..5baaa27 100644
--- a/core/src/main/java/com/google/inject/internal/Errors.java
+++ b/core/src/main/java/com/google/inject/internal/Errors.java
@@ -33,6 +33,7 @@ import com.google.inject.spi.Dependency;
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.io.PrintWriter;
 import java.io.Serializable;
@@ -51,7 +52,7 @@ import java.util.List;
 
 /**
  * A collection of error messages. If this type is passed as a method parameter, the method is
- * considered to have executed succesfully only if new errors were not added to this collection.
+ * considered to have executed successfully only if new errors were not added to this collection.
  *
  * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
  * to create a new Errors instance that contains additional context. All messages added to the
@@ -135,30 +136,30 @@ public final class Errors implements Serializable {
   }
 
   public Errors converterReturnedNull(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
         + " using %s.",
-        stringValue, convert(source), type, matchingConverter);
+        stringValue, convert(source), type, typeConverterBinding);
   }
 
   public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter matchingConverter, Object converted) {
+      TypeConverterBinding typeConverterBinding, Object converted) {
     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Converter returned %s.",
-        stringValue, convert(source), type, matchingConverter, converted);
+        stringValue, convert(source), type, typeConverterBinding, converted);
   }
 
   public Errors conversionError(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding, RuntimeException cause) {
     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Reason: %s",
-        stringValue, convert(source), type, matchingConverter, cause);
+        stringValue, convert(source), type, typeConverterBinding, cause);
   }
 
   public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter a, MatcherAndConverter b) {
+      TypeConverterBinding a, TypeConverterBinding b) {
     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n"
         + " %s and%n"
         + " %s.%n"
@@ -604,7 +605,7 @@ public final class Errors implements Serializable {
     }
 
     boolean appliesTo(Object o) {
-      return type.isAssignableFrom(o.getClass());
+      return o != null && type.isAssignableFrom(o.getClass());
     }
 
     String convert(Object o) {
diff --git a/core/src/main/java/com/google/inject/internal/InheritingState.java b/core/src/main/java/com/google/inject/internal/InheritingState.java
index 4050b1e..288d875 100644
--- a/core/src/main/java/com/google/inject/internal/InheritingState.java
+++ b/core/src/main/java/com/google/inject/internal/InheritingState.java
@@ -24,6 +24,7 @@ import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.Lists;
 import com.google.inject.internal.util.Maps;
 import static com.google.inject.internal.util.Preconditions.checkNotNull;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
@@ -43,7 +44,7 @@ final class InheritingState implements State {
   private final Map<Key<?>, Binding<?>> explicitBindings
       = Collections.unmodifiableMap(explicitBindingsMutable);
   private final Map<Class<? extends Annotation>, Scope> scopes = Maps.newHashMap();
-  private final List<MatcherAndConverter> converters = Lists.newArrayList();
+  private final List<TypeConverterBinding> converters = Lists.newArrayList();
   /*if[AOP]*/
   private final List<MethodAspect> methodAspects = Lists.newArrayList();
   /*end[AOP]*/
@@ -83,19 +84,19 @@ final class InheritingState implements State {
     scopes.put(annotationType, scope);
   }
 
-  public Iterable<MatcherAndConverter> getConvertersThisLevel() {
+  public List<TypeConverterBinding> getConvertersThisLevel() {
     return converters;
   }
 
-  public void addConverter(MatcherAndConverter matcherAndConverter) {
-    converters.add(matcherAndConverter);
+  public void addConverter(TypeConverterBinding typeConverterBinding) {
+    converters.add(typeConverterBinding);
   }
 
-  public MatcherAndConverter getConverter(
+  public TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source) {
-    MatcherAndConverter matchingConverter = null;
+    TypeConverterBinding matchingConverter = null;
     for (State s = this; s != State.NONE; s = s.parent()) {
-      for (MatcherAndConverter converter : s.getConvertersThisLevel()) {
+      for (TypeConverterBinding converter : s.getConvertersThisLevel()) {
         if (converter.getTypeMatcher().matches(type)) {
           if (matchingConverter != null) {
             errors.ambiguousTypeConversion(stringValue, source, type, matchingConverter, converter);
diff --git a/core/src/main/java/com/google/inject/internal/InjectorImpl.java b/core/src/main/java/com/google/inject/internal/InjectorImpl.java
index ab8e281..73ad4d3 100644
--- a/core/src/main/java/com/google/inject/internal/InjectorImpl.java
+++ b/core/src/main/java/com/google/inject/internal/InjectorImpl.java
@@ -45,6 +45,7 @@ import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.ProviderBinding;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
@@ -376,9 +377,9 @@ final class InjectorImpl implements Injector, Lookups {
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
-    MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
+    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
 
-    if (matchingConverter == null) {
+    if (typeConverterBinding == null) {
       // No converter can handle the given type.
       return null;
     }
@@ -386,23 +387,24 @@ final class InjectorImpl implements Injector, Lookups {
     // Try to convert the string. A failed conversion results in an error.
     try {
       @SuppressWarnings("unchecked") // This cast is safe because we double check below.
-      T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type);
+      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
 
       if (converted == null) {
-        throw errors.converterReturnedNull(stringValue, source, type, matchingConverter)
+        throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding)
             .toException();
       }
 
       if (!type.getRawType().isInstance(converted)) {
-        throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted)
+        throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted)
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding,
+          typeConverterBinding);
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
-      throw errors.conversionError(stringValue, source, type, matchingConverter, e)
+      throw errors.conversionError(stringValue, source, type, typeConverterBinding, e)
           .toException();
     }
   }
@@ -412,14 +414,17 @@ final class InjectorImpl implements Injector, Lookups {
     final T value;
     final Provider<T> provider;
     final Binding<String> originalBinding;
+    final TypeConverterBinding typeConverterBinding;
 
     ConvertedConstantBindingImpl(
-        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding) {
+        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding,
+        TypeConverterBinding typeConverterBinding) {
       super(injector, key, originalBinding.getSource(),
           new ConstantFactory<T>(Initializables.of(value)), Scoping.UNSCOPED);
       this.value = value;
       provider = Providers.of(value);
       this.originalBinding = originalBinding;
+      this.typeConverterBinding = typeConverterBinding;
     }
 
     @Override public Provider<T> getProvider() {
@@ -434,6 +439,10 @@ final class InjectorImpl implements Injector, Lookups {
       return value;
     }
 
+    public TypeConverterBinding getTypeConverterBinding() {
+      return typeConverterBinding;
+    }
+
     public Key<String> getSourceKey() {
       return originalBinding.getKey();
     }
@@ -828,7 +837,11 @@ final class InjectorImpl implements Injector, Lookups {
   }
 
   public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
-    return state.getScopes();
+    return Collections.unmodifiableMap(state.getScopes());
+  }
+
+  public List<TypeConverterBinding> getTypeConverterBindings() {
+    return Collections.unmodifiableList(state.getConvertersThisLevel());
   }
 
   private static class BindingsMultimap {
diff --git a/core/src/main/java/com/google/inject/internal/InjectorShell.java b/core/src/main/java/com/google/inject/internal/InjectorShell.java
index 87c6a9a..2e51945 100644
--- a/core/src/main/java/com/google/inject/internal/InjectorShell.java
+++ b/core/src/main/java/com/google/inject/internal/InjectorShell.java
@@ -229,6 +229,15 @@ final class InjectorShell {
         new ProviderInstanceBindingImpl<Logger>(injector, key,
             SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED,
             loggerFactory, ImmutableSet.<InjectionPoint>of()));
+
+    try {
+      Key<org.slf4j.Logger> slf4jKey = Key.get(org.slf4j.Logger.class);
+      SLF4JLoggerFactory slf4jLoggerFactory = new SLF4JLoggerFactory();
+      injector.state.putBinding(slf4jKey,
+          new ProviderInstanceBindingImpl<org.slf4j.Logger>(injector, slf4jKey,
+              SourceProvider.UNKNOWN_SOURCE, slf4jLoggerFactory, Scoping.UNSCOPED,
+              slf4jLoggerFactory, ImmutableSet.<InjectionPoint>of()));
+    } catch (Throwable e) {}
   }
 
   private static class LoggerFactory implements InternalFactory<Logger>, Provider<Logger> {
@@ -248,6 +257,23 @@ final class InjectorShell {
     }
   }
 
+  private static class SLF4JLoggerFactory implements InternalFactory<org.slf4j.Logger>, Provider<org.slf4j.Logger> {
+    public org.slf4j.Logger get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked) {
+      InjectionPoint injectionPoint = dependency.getInjectionPoint();
+      return injectionPoint == null
+          ? org.slf4j.LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME)
+          : org.slf4j.LoggerFactory.getLogger(injectionPoint.getMember().getDeclaringClass());
+    }
+
+    public org.slf4j.Logger get() {
+      return org.slf4j.LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
+    }
+
+    public String toString() {
+      return "Provider<org.slf4j.Logger>";
+    }
+  }
+
   private static class RootModule implements Module {
     final Stage stage;
 
diff --git a/core/src/main/java/com/google/inject/internal/InternalContext.java b/core/src/main/java/com/google/inject/internal/InternalContext.java
index 36bc41a..9930681 100644
--- a/core/src/main/java/com/google/inject/internal/InternalContext.java
+++ b/core/src/main/java/com/google/inject/internal/InternalContext.java
@@ -47,7 +47,7 @@ final class InternalContext {
   }
 
   public Dependency setDependency(Dependency dependency) {
-    Dependency previous = dependency;
+    Dependency previous = this.dependency;
     this.dependency = dependency;
     return previous;
   }
diff --git a/core/src/main/java/com/google/inject/internal/InternalInjectorCreator.java b/core/src/main/java/com/google/inject/internal/InternalInjectorCreator.java
index 44f0065..157a77a 100644
--- a/core/src/main/java/com/google/inject/internal/InternalInjectorCreator.java
+++ b/core/src/main/java/com/google/inject/internal/InternalInjectorCreator.java
@@ -29,6 +29,7 @@ import com.google.inject.internal.util.ImmutableSet;
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.internal.util.Stopwatch;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.TypeConverterBinding;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -287,6 +288,9 @@ public final class InternalInjectorCreator {
     public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
       return delegateInjector.getScopeBindings();
     }
+    public List<TypeConverterBinding> getTypeConverterBindings() {
+      return delegateInjector.getTypeConverterBindings();
+    }
     public <T> Provider<T> getProvider(Key<T> key) {
       throw new UnsupportedOperationException(
         "Injector.getProvider(Key<T>) is not supported in Stage.TOOL");
diff --git a/core/src/main/java/com/google/inject/internal/MatcherAndConverter.java b/core/src/main/java/com/google/inject/internal/MatcherAndConverter.java
deleted file mode 100644
index b618b3f..0000000
--- a/core/src/main/java/com/google/inject/internal/MatcherAndConverter.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2007 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.inject.internal;
-
-import com.google.inject.TypeLiteral;
-import static com.google.inject.internal.util.Preconditions.checkNotNull;
-import com.google.inject.matcher.Matcher;
-import com.google.inject.spi.TypeConverter;
-
-/**
- * @author crazybob@google.com (Bob Lee)
- */
-final class MatcherAndConverter {
-
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-  private final Object source;
-
-  public MatcherAndConverter(Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter, Object source) {
-    this.typeMatcher = checkNotNull(typeMatcher, "type matcher");
-    this.typeConverter = checkNotNull(typeConverter, "converter");
-    this.source = source;
-  }
-
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
-
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
-
-  public Object getSource() {
-    return source;
-  }
-
-  @Override public String toString() {
-    return typeConverter + " which matches " + typeMatcher
-        + " (bound at " + source + ")";
-  }
-}
diff --git a/core/src/main/java/com/google/inject/internal/State.java b/core/src/main/java/com/google/inject/internal/State.java
index 4bf8025..ad6c59f 100644
--- a/core/src/main/java/com/google/inject/internal/State.java
+++ b/core/src/main/java/com/google/inject/internal/State.java
@@ -23,6 +23,7 @@ import com.google.inject.TypeLiteral;
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableMap;
 import com.google.inject.internal.util.ImmutableSet;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.List;
@@ -61,17 +62,17 @@ interface State {
       throw new UnsupportedOperationException();
     }
 
-    public void addConverter(MatcherAndConverter matcherAndConverter) {
+    public void addConverter(TypeConverterBinding typeConverterBinding) {
       throw new UnsupportedOperationException();
     }
 
-    public MatcherAndConverter getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
+    public TypeConverterBinding getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
         Object source) {
       throw new UnsupportedOperationException();
     }
 
-    public Iterable<MatcherAndConverter> getConvertersThisLevel() {
-      return ImmutableSet.of();
+    public List<TypeConverterBinding> getConvertersThisLevel() {
+      return ImmutableList.of();
     }
 
     /*if[AOP]*/
@@ -123,14 +124,14 @@ interface State {
 
   void putAnnotation(Class<? extends Annotation> annotationType, Scope scope);
 
-  void addConverter(MatcherAndConverter matcherAndConverter);
+  void addConverter(TypeConverterBinding typeConverterBinding);
 
   /** Returns the matching converter for {@code type}, or null if none match. */
-  MatcherAndConverter getConverter(
+  TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source);
 
   /** Returns all converters at this level only. */
-  Iterable<MatcherAndConverter> getConvertersThisLevel();
+  List<TypeConverterBinding> getConvertersThisLevel();
 
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
diff --git a/core/src/main/java/com/google/inject/internal/TypeConverterBindingProcessor.java b/core/src/main/java/com/google/inject/internal/TypeConverterBindingProcessor.java
index 1f10349..ceb0657 100644
--- a/core/src/main/java/com/google/inject/internal/TypeConverterBindingProcessor.java
+++ b/core/src/main/java/com/google/inject/internal/TypeConverterBindingProcessor.java
@@ -161,12 +161,12 @@ final class TypeConverterBindingProcessor extends AbstractProcessor {
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBinding(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }
diff --git a/core/src/main/java/com/google/inject/name/NamedImpl.java b/core/src/main/java/com/google/inject/name/NamedImpl.java
index 8690c51..5ccc7c7 100644
--- a/core/src/main/java/com/google/inject/name/NamedImpl.java
+++ b/core/src/main/java/com/google/inject/name/NamedImpl.java
@@ -38,12 +38,13 @@ class NamedImpl implements Named, Serializable {
   }
 
   public boolean equals(Object o) {
-    if (!(o instanceof Named)) {
-      return false;
+    if (o == this) {
+      return true;
     }
-
-    Named other = (Named) o;
-    return value.equals(other.value());
+    if (o instanceof Named) {
+      return value.equals(((Named) o).value());
+    }
+    return false;
   }
 
   public String toString() {
diff --git a/core/src/main/java/com/google/inject/spi/ConvertedConstantBinding.java b/core/src/main/java/com/google/inject/spi/ConvertedConstantBinding.java
index 6c78acb..cd7a0ec 100644
--- a/core/src/main/java/com/google/inject/spi/ConvertedConstantBinding.java
+++ b/core/src/main/java/com/google/inject/spi/ConvertedConstantBinding.java
@@ -35,6 +35,11 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
   T getValue();
 
   /**
+   * Returns the type converter binding used to convert the constant.
+   */
+  TypeConverterBinding getTypeConverterBinding();
+
+  /**
    * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
diff --git a/core/src/main/java/com/google/inject/spi/TypeConverterBinding.java b/core/src/main/java/com/google/inject/spi/TypeConverterBinding.java
index 74f7c73..9564715 100644
--- a/core/src/main/java/com/google/inject/spi/TypeConverterBinding.java
+++ b/core/src/main/java/com/google/inject/spi/TypeConverterBinding.java
@@ -36,7 +36,7 @@ public final class TypeConverterBinding implements Element {
   private final Matcher<? super TypeLiteral<?>> typeMatcher;
   private final TypeConverter typeConverter;
 
-  TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
+  public TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter typeConverter) {
     this.source = checkNotNull(source, "source");
     this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
@@ -62,4 +62,9 @@ public final class TypeConverterBinding implements Element {
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
   }
+
+  @Override public String toString() {
+    return typeConverter + " which matches " + typeMatcher
+        + " (bound at " + source + ")";
+  }
 }
diff --git a/core/src/test/java/com/google/inject/AllTests.java b/core/src/test/java/com/google/inject/AllTests.java
index bcb2f14..f1c9d88 100644
--- a/core/src/test/java/com/google/inject/AllTests.java
+++ b/core/src/test/java/com/google/inject/AllTests.java
@@ -22,7 +22,6 @@ import com.google.inject.internal.util.Jsr166HashMapTest;
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.internal.util.MapMakerTestSuite;
 import com.google.inject.internal.MoreTypesTest;
-import com.google.inject.internal.ProxyFactoryTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamedEquivalanceTest;
@@ -45,12 +44,13 @@ import com.googlecode.guice.GuiceTck;
 import java.util.Enumeration;
 import java.util.Set;
 import junit.framework.Test;
+import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
 /**
  * @author crazybob@google.com (Bob Lee)
  */
-public class AllTests {
+public class AllTests extends TestCase {
 
   private static final Set<String> SUPPRESSED_TEST_NAMES = ImmutableSet.of(
       "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
@@ -138,7 +138,7 @@ public class AllTests {
     suite.addTestSuite(TypesTest.class);
 
     /*if[AOP]*/
-    suite.addTestSuite(ProxyFactoryTest.class);
+    suite.addTestSuite(com.google.inject.internal.ProxyFactoryTest.class);
     suite.addTestSuite(IntegrationTest.class);
     suite.addTestSuite(MethodInterceptionTest.class);
     suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
@@ -146,7 +146,7 @@ public class AllTests {
 
     // googlecode.guice
     suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
-    suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
+////suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
     suite.addTestSuite(Jsr330Test.class);
 
     return removeSuppressedTests(suite, SUPPRESSED_TEST_NAMES);
diff --git a/core/src/test/java/com/google/inject/BindingTest.java b/core/src/test/java/com/google/inject/BindingTest.java
index acaec62..1b71991 100644
--- a/core/src/test/java/com/google/inject/BindingTest.java
+++ b/core/src/test/java/com/google/inject/BindingTest.java
@@ -275,6 +275,7 @@ public class BindingTest extends TestCase {
     }
   }
 
+/*if[AOP]*/
   public void testToConstructorAndMethodInterceptors() throws NoSuchMethodException {
     final Constructor<D> constructor = D.class.getConstructor(Stage.class);
     final AtomicInteger count = new AtomicInteger();
@@ -297,6 +298,7 @@ public class BindingTest extends TestCase {
     d.hashCode();
     assertEquals(2, count.get());
   }
+/*end[AOP]*/
 
   public void testInaccessibleConstructor() throws NoSuchMethodException {
     final Constructor<E> constructor = E.class.getDeclaredConstructor(Stage.class);
diff --git a/core/src/test/java/com/google/inject/TypeConversionTest.java b/core/src/test/java/com/google/inject/TypeConversionTest.java
index ead3c99..3d57d31 100644
--- a/core/src/test/java/com/google/inject/TypeConversionTest.java
+++ b/core/src/test/java/com/google/inject/TypeConversionTest.java
@@ -19,7 +19,9 @@ package com.google.inject;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.matcher.Matchers;
+import com.google.inject.spi.ConvertedConstantBinding;
 import com.google.inject.spi.TypeConverter;
+import com.google.inject.spi.TypeConverterBinding;
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.util.Date;
@@ -209,6 +211,14 @@ public class TypeConversionTest extends TestCase {
     });
 
     assertSame(result, injector.getInstance(DateHolder.class).date);
+
+    Binding<Date> binding = injector.getBinding(Key.get(Date.class, NumericValue.class));
+    assertTrue(binding instanceof ConvertedConstantBinding<?>);
+
+    TypeConverterBinding converterBinding = ((ConvertedConstantBinding<?>)binding).getTypeConverterBinding();
+    assertEquals("CustomConverter", converterBinding.getTypeConverter().toString());
+
+    assertTrue(injector.getTypeConverterBindings().contains(converterBinding));
   }
 
   public void testInvalidCustomValue() throws CreationException {
diff --git a/core/src/test/java/com/google/inject/internal/util/LineNumbersTest.java b/core/src/test/java/com/google/inject/internal/util/LineNumbersTest.java
index 8931cab..ead8190 100644
--- a/core/src/test/java/com/google/inject/internal/util/LineNumbersTest.java
+++ b/core/src/test/java/com/google/inject/internal/util/LineNumbersTest.java
@@ -29,8 +29,8 @@ import junit.framework.TestCase;
  */
 public class LineNumbersTest extends TestCase {
 
-  /*if[AOP]*/
   public void testCanHandleLineNumbersForGuiceGeneratedClasses() {
+    /*if[AOP]*/
     try {
       Guice.createInjector(new AbstractModule() {
         protected void configure() {
@@ -51,8 +51,8 @@ public class LineNumbersTest extends TestCase {
           "for parameter 0 at " + A.class.getName() + ".<init>(LineNumbersTest.java:",
           "at " + LineNumbersTest.class.getName(), ".configure(LineNumbersTest.java:");
     }
-  }
   /*end[AOP]*/
+  }
 
   static class A {
     @Inject A(B b) {}
diff --git a/core/src/test/java/com/google/inject/spi/ElementsTest.java b/core/src/test/java/com/google/inject/spi/ElementsTest.java
index aa1777d..d1275c7 100644
--- a/core/src/test/java/com/google/inject/spi/ElementsTest.java
+++ b/core/src/test/java/com/google/inject/spi/ElementsTest.java
@@ -1127,7 +1127,9 @@ public class ElementsTest extends TestCase {
                 assertEquals(field,
                     getOnlyElement(constructorBinding.getInjectableMembers()).getMember());
                 assertEquals(2, constructorBinding.getDependencies().size());
+/*if[AOP]*/
                 assertEquals(ImmutableMap.of(), constructorBinding.getMethodInterceptors());
+/*end[AOP]*/
                 return null;
               }
             });
diff --git a/core/src/test/java/com/googlecode/guice/BytecodeGenTest.java b/core/src/test/java/com/googlecode/guice/BytecodeGenTest.java
index 882049c..f05f10b 100644
--- a/core/src/test/java/com/googlecode/guice/BytecodeGenTest.java
+++ b/core/src/test/java/com/googlecode/guice/BytecodeGenTest.java
@@ -197,6 +197,7 @@ public class BytecodeGenTest extends TestCase {
     }
   }
   
+/*******************************************************************************
   public void testProxyClassUnloading() {
     Object testObject = Guice.createInjector(interceptorModule, testModule)
         .getInstance(proxyTestClass);
@@ -211,10 +212,10 @@ public class BytecodeGenTest extends TestCase {
     // null the proxy
     testObject = null;
 
-    /*
+    |*
      * this should be enough to queue the weak reference
      * unless something is holding onto it accidentally.
-     */
+     *|
     String[] buf;
     System.gc();
     buf = new String[8 * 1024 * 1024];
@@ -234,6 +235,7 @@ public class BytecodeGenTest extends TestCase {
     // If it fails, run the test again to make sure it's failing reliably.
     assertNull(clazzRef.get());
   }
+*******************************************************************************/
 
   public void testProxyingPackagePrivateMethods() {
     Injector injector = Guice.createInjector(interceptorModule);
diff --git a/extensions/mini/src/main/java/com/google/inject/mini/MiniGuice.java b/extensions/mini/src/main/java/com/google/inject/mini/MiniGuice.java
index 5484a79..5b319b8 100644
--- a/extensions/mini/src/main/java/com/google/inject/mini/MiniGuice.java
+++ b/extensions/mini/src/main/java/com/google/inject/mini/MiniGuice.java
@@ -23,11 +23,11 @@ import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
@@ -45,7 +45,7 @@ public final class MiniGuice {
   private MiniGuice() {}
 
   private final Map<Key, Provider<?>> bindings = new HashMap<Key, Provider<?>>();
-  private final Queue<RequiredKey> requiredKeys = new ArrayDeque<RequiredKey>();
+  private final Queue<RequiredKey> requiredKeys = new LinkedList<RequiredKey>();
   private final Set<Key> singletons = new HashSet<Key>();
 
   /**
diff --git a/extensions/persist/src/main/java/com/google/inject/persist/jpa/JpaPersistModule.java b/extensions/persist/src/main/java/com/google/inject/persist/jpa/JpaPersistModule.java
index 510f502..ded3642 100644
--- a/extensions/persist/src/main/java/com/google/inject/persist/jpa/JpaPersistModule.java
+++ b/extensions/persist/src/main/java/com/google/inject/persist/jpa/JpaPersistModule.java
@@ -46,7 +46,7 @@ public final class JpaPersistModule extends PersistModule {
   private final String jpaUnit;
 
   public JpaPersistModule(String jpaUnit) {
-    Preconditions.checkArgument(null != jpaUnit && !jpaUnit.isEmpty(),
+    Preconditions.checkArgument(null != jpaUnit && jpaUnit.length() > 0,
         "JPA unit name must be a non-empty string.");
     this.jpaUnit = jpaUnit;
   }
diff --git a/core/src/main/java/com/google/inject/internal/ConstructionProxy.java b/core/src/main/java/com/google/inject/internal/ConstructionProxy.java
index 930d660..7233ae5 100644
--- a/core/src/main/java/com/google/inject/internal/ConstructionProxy.java
+++ b/core/src/main/java/com/google/inject/internal/ConstructionProxy.java
@@ -22,7 +22,6 @@ import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Proxies calls to a {@link java.lang.reflect.Constructor} for a class
@@ -52,6 +51,6 @@ interface ConstructionProxy<T> {
   /**
    * Returns the interceptors applied to each method, in order of invocation.
    */
-  ImmutableMap<Method, List<MethodInterceptor>> getMethodInterceptors();
+  ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();
   /*end[AOP]*/
 }
diff --git a/core/src/main/java/com/google/inject/internal/DefaultConstructionProxyFactory.java b/core/src/main/java/com/google/inject/internal/DefaultConstructionProxyFactory.java
index c654bbc..74c6756 100644
--- a/core/src/main/java/com/google/inject/internal/DefaultConstructionProxyFactory.java
+++ b/core/src/main/java/com/google/inject/internal/DefaultConstructionProxyFactory.java
@@ -24,7 +24,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Produces construction proxies that invoke the class constructor.
@@ -97,7 +96,7 @@ final class DefaultConstructionProxyFactory<T> implements ConstructionProxyFacto
         return constructor;
       }
       /*if[AOP]*/
-      public ImmutableMap<Method, List<MethodInterceptor>>
+      public ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>>
           getMethodInterceptors() {
         return ImmutableMap.of();
       }
