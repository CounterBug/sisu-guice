Description: Replace class-level global SINGLETON lock with a finer-grained lock
Author: Stuart McCulloch <mcculls@gmail.com>
Bug-Google: http://code.google.com/p/google-guice/issues/detail?id=183
Last-Update: 2014-10-31

diff --git a/core/src/com/google/inject/internal/Scoping.java b/core/src/com/google/inject/internal/Scoping.java
index 10afcba..334aaef 100644
--- a/core/src/com/google/inject/internal/Scoping.java
+++ b/core/src/com/google/inject/internal/Scoping.java
@@ -239,14 +239,9 @@ public abstract class Scoping {
 
     Scope scope = scoping.getScopeInstance();
 
-    try {
-      SingletonScope.singletonCreationPerRootInjectorLock.set(injector.state.singletonCreationLock());
       Provider<T> scoped
           = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));
       return new InternalFactoryToProviderAdapter<T>(scoped, source);
-    } finally {
-      SingletonScope.singletonCreationPerRootInjectorLock.set(null);
-    }
   }
 
   /**
diff --git a/core/src/com/google/inject/internal/SingletonScope.java b/core/src/com/google/inject/internal/SingletonScope.java
index e98a030..458cd34 100644
--- a/core/src/com/google/inject/internal/SingletonScope.java
+++ b/core/src/com/google/inject/internal/SingletonScope.java
@@ -2,7 +2,6 @@ package com.google.inject.internal;
 
 import com.google.inject.Injector;
 import com.google.inject.Key;
-import com.google.inject.OutOfScopeException;
 import com.google.inject.Provider;
 import com.google.inject.ProvisionException;
 import com.google.inject.Scope;
@@ -17,27 +16,7 @@ public class SingletonScope implements Scope {
   /** A sentinel value representing null. */
   private static final Object NULL = new Object();
 
-  /**
-   * Lock to use for new instances creation. This allows a per-root-Injector singleton lock,
-   * instead of a global lock across the JVM. Is set only during call to {@link #scope}.
-   *
-   * This is necessary because users have coded to a single {@link Scopes#SINGLETON} instance, 
-   * and we cannot change that.  Additionally, we can't reference the injector from a Key or
-   * Provider (the only variables available to the {@link #scope} method).  Therefore, we rely
-   * on the injector implementation to explicitly set/unset the lock surrounding
-   * creation of the Provider the scope creates.
-   *
-   * @see {@link Scoping#scope(Key, InjectorImpl, InternalFactory, Object, Scoping)} for details.
-   */
-  static final ThreadLocal<Object> singletonCreationPerRootInjectorLock =
-      new ThreadLocal<Object>();
-
   public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {
-    // lock is referenced from anonymous class instance
-    final Object rootInjectorLock = singletonCreationPerRootInjectorLock.get();
-    if (rootInjectorLock == null) {
-      throw new OutOfScopeException("Singleton scope should only be used from Injector");
-    }
     return new Provider<T>() {
       /*
        * The lazily initialized singleton instance. Once set, this will either have type T or will
@@ -50,14 +29,9 @@ public class SingletonScope implements Scope {
       public T get() {
         if (instance == null) {
           /*
-           * Use a pretty coarse lock. We don't want to run into deadlocks
-           * when two threads try to load circularly-dependent objects.
-           * Maybe one of these days we will identify independent graphs of
-           * objects and offer to load them in parallel.
-           *
            * This block is re-entrant for circular dependencies.
            */
-          synchronized (rootInjectorLock) {
+          synchronized (this) {
             if (instance == null) {
               T provided = creator.get();
 
